<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on Katas</title>
    <link>https://katas.garrardkitchen.com/</link>
    <description>Recent content in Introduction on Katas</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="https://katas.garrardkitchen.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Net Core Web App</title>
      <link>https://katas.garrardkitchen.com/posts/net-core-web-app/</link>
      <pubDate>Mon, 27 Apr 2020 16:30:23 +0100</pubDate>
      
      <guid>https://katas.garrardkitchen.com/posts/net-core-web-app/</guid>
      <description>.NET Core Web Application Create a .NET Core C# web application that renders a list of random names api. Load Names from an API, where the URI for API is set in an appSettings file. Use the Configuration IOptions pattern and the HttpClientFactory factory class. Create a test using Moq and xUnit, and return Stub from HttpMessageHandler. Use a different API URI per environment.
Requirements:
   Tech:
 .</description>
    </item>
    
    <item>
      <title>Net Core Web App Docker</title>
      <link>https://katas.garrardkitchen.com/posts/net-core-web-app-docker/</link>
      <pubDate>Mon, 27 Apr 2020 16:30:11 +0100</pubDate>
      
      <guid>https://katas.garrardkitchen.com/posts/net-core-web-app-docker/</guid>
      <description>.NET Core Web Application hosted in Docker container running in Kubernetes Create a Redis Caching layer for above .NET Core random name web application. Have a TTL of 10 seconds. Host in Docker container. Create an Kubernetes deployment manifest. Refs: deployment example
Requirements:
   Tech:
 .NET Core 3.1 Redis Docker Kubernetes Kubectl MiniKube  References
 random name generator API  </description>
    </item>
    
    <item>
      <title>React Express Socketio</title>
      <link>https://katas.garrardkitchen.com/posts/react-express-socketio/</link>
      <pubDate>Mon, 27 Apr 2020 15:08:17 +0100</pubDate>
      
      <guid>https://katas.garrardkitchen.com/posts/react-express-socketio/</guid>
      <description>react-function-components Requirements:
  Create a React application and run it to get default page
  Remove all extant files
  Create a new App.js starter file
  Add socket-io to server.js
  Add socket-io-client to App component
  Send &amp;lsquo;Welcome!&amp;rsquo; message on client connect
  Render &amp;lsquo;Welcome!&amp;rsquo; message from the server
  Tech:
 nodejs npm npx react (create-react-app) socket.io (socker-io) socket.io-client (https://www.</description>
    </item>
    
    <item>
      <title>React Function Components</title>
      <link>https://katas.garrardkitchen.com/posts/react-function-components/</link>
      <pubDate>Mon, 27 Apr 2020 15:08:04 +0100</pubDate>
      
      <guid>https://katas.garrardkitchen.com/posts/react-function-components/</guid>
      <description>react-function-components Requirements:
  Create a React application and run it to get default page
  Remove all extant files
  Create a new App.js starter file
  Add a new function component that renders an input field and a button - call this Input
  Add a new function component that renders a table - call this Table
  Import and add both new function components as child components to the App</description>
    </item>
    
    <item>
      <title>Idempotent Consumer</title>
      <link>https://katas.garrardkitchen.com/posts/idempotent-consumer/</link>
      <pubDate>Mon, 27 Apr 2020 15:07:50 +0100</pubDate>
      
      <guid>https://katas.garrardkitchen.com/posts/idempotent-consumer/</guid>
      <description>idempotent consumer Requirements:
  Create a consumer that accepts different message reference types that each contains one of these properties:
 A message that contains an Id A message that contains a TTL A message that contains a before and after state    The consumer must filter out any duplicate message that contains an Id that has already been processed
  The consumer must filter out any messages that have expired (TTL)</description>
    </item>
    
  </channel>
</rss>